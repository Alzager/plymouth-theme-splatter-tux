#----------------------------------------- Configuration --------------------------------
max_size = 0.8; # Maximum ammount of height and width that should be used

background.red = 0.2;
background.green = 0.2;
background.blue = 0.2;

start_progress = 0.05;
end_progress = 0.83;
opacity_increase = 0.5; # Opacity increase during fade in
background_fade_step = 0.05; # Percentage of each background fade in/out step
#----------------------------------------- End Configuration --------------------------------

res = 1;
background_fade = 0;
# Initialize boot
if (Plymouth.GetMode() == "boot" || Plymouth.GetMode() == "resume")
{
	Window.SetBackgroundTopColor(0, 0, 0);
	Window.SetBackgroundBottomColor(0, 0, 0);
	stage.number = 1;
	# Get correct resolution for images
	while (1)
	{
		stage[1].splatter[1].image = Image("splatter_" + res + "_1_1.png");
		if (! stage[1].splatter[1].image)
		{
			res = res - 1;
			break;
		}
		if (Window.GetWidth() * max_size < stage[1].splatter[1].image.GetWidth() || Window.GetHeight() * max_size < stage[1].splatter[1].image.GetHeight())
		{
			res = res - 1;
			break;
		}
		res = res + 1;
	}

	# Get positioning coordinates
	stage[1].splatter[1].image = Image("splatter_" + res + "_1_1.png");
	splatter_x = (Window.GetWidth() - stage[1].splatter[1].image.GetWidth()) / 2;
	splatter_y = (Window.GetHeight() - stage[1].splatter[1].image.GetHeight()) / 2;

	# Get number of stages
	while (1)
	{
		stage.number = stage.number + 1;
		stage[stage.number].splatter[1].image = Image("splatter_" + res + "_" + stage.number + "_1.png");
		if (! stage[stage.number].splatter[1].image)
		{
			stage.number = stage.number - 1;
			break;
		}
	randomized[stage.number] = 0;
	}
	randomized[1] = 0;

	# Get number of splatters for each stage
	for (s = 1; s <= stage.number; s++)
	{
		stage[s].number = 1;
		while (1)
		{
			stage[s].number = stage[s].number  + 1;
			stage[s].splatter[stage[s].number].image = Image("splatter_" + res + "_" + s + "_" + stage[s].number  + ".png");
			if (! stage[s].splatter[stage[s].number].image)
			{
				stage[s].number = stage[s].number  - 1;
				break;
			}
		}
	}

	# Set progresses
	number_splatters = 0;
	for (s = 1; s <= stage.number; s++)
	{
		number_splatters = number_splatters + stage[s].number;
	}
	end = end_progress - start_progress;
	number_splatters_so_far = 0;
	for (s = 1; s <= stage.number; s++)
	{
		for (i = 1; i <= stage[s].number; i++)
		{
			number_splatters_so_far = number_splatters_so_far + 1;
			stage[s].splatter[i].progress = number_splatters_so_far / number_splatters * end + start_progress;
		}
	}
}

# Initialize shutdown
if (Plymouth.GetMode() == "shutdown" || Plymouth.GetMode() == "suspend")
{
	Window.SetBackgroundTopColor(background.red, background.green, background.blue);
	Window.SetBackgroundBottomColor(background.red, background.green, background.blue);
	# Get correct resolution for images
	while (1)
	{
		background.image = Image("background_" + res + ".png");
		if (! background.image)
		{
			res = res - 1;
			break;
		}
		if (Window.GetWidth() * max_size < background.image.GetWidth() || Window.GetHeight() * max_size < background.image.GetHeight())
		{
			res = res - 1;
			break;
		}
		res = res + 1;
	}

	# Get positioning coordinates
	background.image = Image("background_" + res + ".png");
	splatter_x = (Window.GetWidth() - background.image.GetWidth()) / 2;
	splatter_y = (Window.GetHeight() - background.image.GetHeight()) / 2;

	# Load sprite
	background.sprite = Sprite();
	background.sprite.SetImage(background.image);
	background.sprite.SetPosition(splatter_x, splatter_y, 10);
	background.sprite.SetOpacity(1);
	
	shutdown.image = Image("shutdown_" + res + "_1.png");
	shutdown.sprite = Sprite();
	shutdown.sprite.SetImage(shutdown.image);
	shutdown.sprite.SetPosition(splatter_x, splatter_y, 20);
	shutdown.sprite.SetOpacity(0);
	count_shutdown = -5;
}

# Create randomized array
fun random_array (max)
{
	max_random = max;
	for (i = 0; i <= max; i++)
	{
		to_mix[i] = 0;
	}
	for (i = 1; i <= max; i++)
	{
		random_position = Math.Int((Math.Random() * max_random)) + 1;
		max_random = max_random - 1;
		for (j = 1; j <= random_position; j++)
		{
			if (to_mix[j] > 0)
			{
				random_position = random_position + 1;
			}
		}
		to_mix[random_position] = i;
	}
	return to_mix;
}

# Boot animation
fun boot_animation (duration, progress)
{
	if (background_fade < 1 && start_progress <= progress)
	{
		background_fade = Math.Clamp(background_fade + background_fade_step, 0, 1);
		Window.SetBackgroundTopColor(background.red * background_fade, background.green * background_fade, background.blue * background_fade);
		Window.SetBackgroundBottomColor(background.red * background_fade, background.green * background_fade, background.blue * background_fade);
	}
	for (s = 1; s <= stage.number; s++)
	{
		if (randomized[s] == 0 && stage[s].splatter[1].progress <= progress)
		{
			randomized[s] = 1;
			temp_order = random_array(stage[s].number);
			for (i = 1; i <= stage[s].number; i++)
			{
				stage[s].order[i] = (temp_order[i] + Math.Int((duration + progress) * 1000)) % stage[s].number  + 1;
				stage[s].splatter[i].initialized = 0;
			}
		}
		for (i = 1; i <= stage[s].number; i++)
		{
			if (stage[s].splatter[i].progress <= progress && stage[s].splatter[i].initialized == 0)
			{
				stage[s].splatter[i].sprite = Sprite();
				stage[s].splatter[i].sprite.SetImage(stage[s].splatter[stage[s].order[i]].image);
				stage[s].splatter[i].sprite.SetPosition(splatter_x, splatter_y, s);
				stage[s].splatter[i].sprite.SetOpacity(0);
				stage[s].splatter[i].initialized = 1;
			}
			if (stage[s].splatter[i].initialized == 1 && stage[s].splatter[i].sprite.GetOpacity() < 1)
			{
				stage[s].splatter[i].sprite.SetOpacity(Math.Min(stage[s].splatter[i].sprite.GetOpacity() + opacity_increase, 1));
			}
		}
	}
}

# Shutdown animation
fun shutdown_animation ()
{
	count_shutdown = count_shutdown + 1;
	shutdown.image = Image("shutdown_" + res + "_" + count_shutdown + ".png");
	if (shutdown.image)
	{
		shutdown.sprite.SetImage(shutdown.image);
		shutdown.sprite.SetPosition(splatter_x, splatter_y, 20);
		shutdown.sprite.SetOpacity(1);
		background.sprite.SetOpacity(1);
	}
	else
	{
		if(count_shutdown > 1)
		{
			background_fade = Math.Clamp(background_fade + background_fade_step, 0, 1);
			background.sprite.SetOpacity(0);
			shutdown.sprite.SetOpacity(0);
			Window.SetBackgroundTopColor(background.red * (1 - background_fade), background.green * (1 - background_fade), background.blue * (1 - background_fade));
			Window.SetBackgroundBottomColor(background.red * (1 - background_fade), background.green * (1 - background_fade), background.blue * (1 - background_fade));
		}
	}
}

fun refresh_callback ()
{
	if (Plymouth.GetMode() == "shutdown" || Plymouth.GetMode() == "suspend")
	{
		shutdown_animation();
	}
}

Plymouth.SetRefreshFunction (refresh_callback);

#----------------------------------------- Dialogue --------------------------------

status = "normal";

fun dialog_setup()
{
	local.box;
	local.lock;
	local.entry;

	box.image = Image("box.png");
	lock.image = Image("lock.png");
	entry.image = Image("entry.png");

	box.sprite = Sprite(box.image);
	box.x = Window.GetWidth()  / 2 - box.image.GetWidth ()/2;
	box.y = Window.GetHeight() / 2 - box.image.GetHeight()/2;
	box.z = 10000;
	box.sprite.SetPosition(box.x, box.y, box.z);

	lock.sprite = Sprite(lock.image);
	lock.x = box.x + box.image.GetWidth()/2 - (lock.image.GetWidth() + entry.image.GetWidth()) / 2;
	lock.y = box.y + box.image.GetHeight()/2 - lock.image.GetHeight()/2;
	lock.z = box.z + 1;
	lock.sprite.SetPosition(lock.x, lock.y, lock.z);

	entry.sprite = Sprite(entry.image);
	entry.x = lock.x + lock.image.GetWidth();
	entry.y = box.y + box.image.GetHeight()/2 - entry.image.GetHeight()/2;
	entry.z = box.z + 1;
	entry.sprite.SetPosition(entry.x, entry.y, entry.z);

	global.dialog.box = box;
	global.dialog.lock = lock;
	global.dialog.entry = entry;
	global.dialog.bullet_image = Image("bullet.png");
	dialog_opacity (1);
}

fun dialog_opacity(opacity)
{
	dialog.box.sprite.SetOpacity (opacity);
	dialog.lock.sprite.SetOpacity (opacity);
	dialog.entry.sprite.SetOpacity (opacity);
	for (index = 0; dialog.bullet[index]; index++)
	{
		dialog.bullet[index].sprite.SetOpacity(opacity);
	}
}

fun display_normal_callback ()
{
	global.status = "normal";
	if (global.dialog)
	dialog_opacity (0);
}

fun display_password_callback (prompt, bullets)
{
	global.status = "password";
	if (!global.dialog)
	dialog_setup();
	else
	dialog_opacity(1);
	for (index = 0; dialog.bullet[index] || index < bullets; index++)
	{
		if (!dialog.bullet[index])
		{
			dialog.bullet[index].sprite = Sprite(dialog.bullet_image);
			dialog.bullet[index].x = dialog.entry.x + index * dialog.bullet_image.GetWidth();
			dialog.bullet[index].y = dialog.entry.y + dialog.entry.image.GetHeight() / 2 - dialog.bullet_image.GetHeight() / 2;
			dialog.bullet[index].z = dialog.entry.z + 1;
			dialog.bullet[index].sprite.SetPosition(dialog.bullet[index].x, dialog.bullet[index].y, dialog.bullet[index].z);
		}
		if (index < bullets)
		dialog.bullet[index].sprite.SetOpacity(1);
		else
		dialog.bullet[index].sprite.SetOpacity(0);
	}
}

Plymouth.SetDisplayNormalFunction(display_normal_callback);
Plymouth.SetDisplayPasswordFunction(display_password_callback);

#----------------------------------------- Progress --------------------------------

fun progress_callback (duration, progress)
{
	if (Plymouth.GetMode() == "boot" || Plymouth.GetMode() == "resume")
	{
		boot_animation(duration, progress);
	}
}

Plymouth.SetBootProgressFunction(progress_callback);

#----------------------------------------- Quit --------------------------------

fun quit_callback ()
{
}

Plymouth.SetQuitFunction(quit_callback);

#----------------------------------------- Message --------------------------------

message_sprite = Sprite();
message_sprite.SetPosition(10, 10, 10000);

fun message_callback (text)
{
	my_image = Image.Text(text, 1, 1, 1);
	message_sprite.SetImage(my_image);
}

Plymouth.SetMessageFunction(message_callback);

#----------------------------------------- MountRoot --------------------------------

fun root_callback ()
{
}

Plymouth.SetRootMountedFunction(root_callback);
